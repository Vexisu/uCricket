\chapter{Specyfikacja zewnętrzna}
\label{ch:04}
\section{Kompilator}
\subsection{Wymagania}
Do uruchomienia kompilatora wymagane jest zapewnienie odpowiedniego środowiska uruchomieniowego składającego się z:
\begin{itemize}
\item systemu operacyjnego z rodziny GNU/Linux lub środowiska uruchomieniowego zapewniającego warunki pracy dla programów kompilowanych dla systemów GNU/Linux np. maszyna wirtualna, WSL, kontener Docker/Podman/Distrobox;
\item maszyna wirtualna Java w wersji 17 lub wyższej;
\item zestaw narzędzi avr-gcc wraz z linkerem i assemblerem.
\end{itemize}

\subsection{Instalacja}
Kompilator dostarczany jest jako archiwum programu Java w formacie .jar. Oprogramowanie LLVM zostało dołączone w archiwum jako biblioteka w formie binarnej dla platformy GNU/Linux.

\subsection{Użycie kompilatora}
Uruchomienie kompilatora odbywa się poprzez przekazanie maszynie wirtualnej programu kompilatora oraz dodaniu nazwy głównego pliku źródłowego bez rozszerzenia.
\begin{lstlisting}
java -jar uCricket.jar [glowny_plik_zrodlowy]
\end{lstlisting}
Kompilator zwraca w pliku \lstinline|output.s| program w języku assembly. Do zbudowania pliku binarnego, wykorzystywany jest \lstinline|avr-gcc|. Poniższe polecenie generuje plik \lstinline|output.bin| przeznaczony dla mikrokontrolera ATmega328P.
\begin{lstlisting}
avr-gcc -mmcu=atmega328p -o output.bin output.s
\end{lstlisting}
W celu wygenerowania pliku przeznaczonego do programowania przez narzędzie \lstinline|avrdude|, możliwe jest utworzenie pliku w formacie Intel HEX. Obywa się to poprzez wykorzystanie narzędzia \lstinline|avr-objcopy|. Poniższe polecenie generuje z pliku binarnego \lstinline|output.bin| plik \lstinline|output.hex|.
\begin{lstlisting}
avr-objcopy -j .text -j .data -O ihex output.bin output.hex
\end{lstlisting}
Programowanie mikrokontrolera kodem wynikowym możliwe jest dzięki wykonaniu poniższej komendy. W danym przykładzie użyty został programator USBasp wraz z mikrokontrolerem ATmega328P.
\begin{lstlisting}
sudo avrdude -p atmega328p -c usbasp -P usb -F -U flash:w:output.hex:i
\end{lstlisting}

\section{Język programowania}
\subsection{Konwencja nazewniczna identyfikatorów}
Nazywanie elementów definiowanych przez użytkownika wymaga ścisłego używania nazw zgodnych z konwencją zapisu identyfikatorów. Identyfikatory przyjmują znaki alfanumeryczne, włącznie z dużymi i małymi literami, nie mogą zaczynać się cyfrą.

\subsection{Pliki źródłowe}
Nazwy plików źródłowych muszą spełniać wymagania zapisu identyfikatorów. Nazwy te są wykorzystywane do identyfikacji plików źródłowych podczas dołączania źródeł między sobą i są niezależne od nazw przestrzeni (scopes). Rozszerzeniem dla plików źródłowych jest \lstinline|.uchirp|.

\subsection{Praca z wieloma plikami źródłowymi}
Pliki źródłowe mogą być łączone między sobą poprzez użycie słowa kluczowego \lstinline|import|:
\begin{lstlisting}
import katalog1:katalog2:NazwaPliku;
\end{lstlisting}
Katalogi w składni instrukcji \lstinline|import| oddzielane są dwukropkami i muszą spełniać wymagania zapisu identyfikatorów. Nazwę pliku źródłowego należy przekazywać do instrukcji bez rozszerzenia, jest ono dodawane w trakcie skanowania plików źródłowych. 

\subsection{Typy danych}
Język programowania wspiera kilka głównych typów danych wykorzystywanych w innych językach programowania. Typy danych muszą być ściśle definiowane w trakcie trakcie ich używania. W innym przypadku, kompilator przerwie proces kompilacji w trakcie analizy statycznej. Tabela \ref{tbl:typy-danych} przedstawia typy daynch wspieraje przez język programowania.

\begin{table}[h!]
\begin{tabular}{@{}llll@{}}
\toprule
Typ danych & Słowa & Definicja wartości & Opis \\ \midrule
Boolean & 1 & true/false & \begin{tabular}[c]{@{}l@{}}Przechowuje wartość logiczną.\\ Wykorzystywany w instrukcjach warunkowych\\ i pętlach.\end{tabular} \\
Byte & 1 & 1b, 127b & Typ liczby całkowitej ośmio-bitowej. \\
Integer & 2 & 1, 32767 & Typ liczby całkowitej szesnasto-bitowej. \\
Float & 4 & 1.0, 123.456 & \begin{tabular}[c]{@{}l@{}}Typ liczy zmienno-przecinkowej\\ trzydziestodwu-bitowej.\end{tabular} \\ \bottomrule
\end{tabular}
\caption{Typy danych obsługiwane przez język uCricket}
\label{tbl:typy-danych}
\end{table}
\subsection{Zmienne}
Zmienne mogą być defoniowane jako globalne oraz logalne w obszarze bloków funkcji, zmiennych i pętl. Typowanie zmiennych jest zawsze wymagane. Nie wymaga ono natomiast przypisania wartości. Definiowanie zmiennych odbywa się w następujący sposób:
\begin{lstlisting}
var<Boolean> boolValue = true;
var<Byte> byteValue = 12b;
var<Integer> unassignedIntValue;
\end{lstlisting}
W trakcie przypisywania wartości do zmiennej możliwe jest użycie wyrażenia arytmetyczno-logicznego. Pozwala to także na zmianę wartości zmiennej z użyciem jej wcześniejszej wartości.
\begin{lstlisting}
var<Integer> i = 1;
i = i + 1; // Inkrementacja wartosci zmiennej i
\end{lstlisting}
Pamięć alokowana przez zmienne jest zwalniana, gdy część wykonywana programu przesunie się poza klamry np. po wyjściu z instrukcji warunkowej. Nie możliwe jest także odwoływanie się do zmiennych lokalnych wpisanych w klamry.
\begin{lstlisting}
if (true){
	var<Integer> i = 0;
}
i = i + 1; // Blad nieistniejacej zmiennej.
\end{lstlisting}
\subsection{Wskaźniki}
Mechanizm wskaźników pozwala na bezpośredni dostęp do przestrzeni adresowej mikrokontrolera. Dzięku niemu możliwy jest także dostęp do rejestrów i portów wejścia wyjścia.
Definiowanie wskaźników odbywa się w sposób podobny do definicji zmiennych. Domyślnie, w odróżnieniu do zmiennych, definicja wskaźnika alokuje pamięć właściwą oraz adresową. Poniższy przykład pokazuje definicję wskaźnika oraz inkrementację jego wartości.
\begin{lstlisting}
ptr<Integer> i = 0;
i = i + 1;
\end{lstlisting}
Z perspektywy programisty, operacje na wskaźnikach wyglądają tak samo, jak operacje na zminnych.
Wskaźniki umożliwiają także na przypisanie oraz zmianę wartości bez alokacji pamięci właściwej. Poniższy przykład przedstawia przypisanie wartości do portów wejścia-wyjścia mikrokontrolera ATmega328P.
\begin{lstlisting}
ptr<Byte> port <- 37; // Utworzenie wskaznika z adresem portu B
port = 255; // Ustawienie wszystkich bitow na wartosc 1
port <- 40; // Zmiana adresu na adres portu C
port = 0; // Ustawienie wszystkich bitow na wartosc 0
\end{lstlisting}

\subsection{Operatory arytmetyczno-logiczne}
Język programowania uCricket implmeentuje wiele operatorów arytmetyczno-logicznych. Tabela \ref{tbl:operatory-arytmetyczno-logiczne} opisuje zbór operatorów obsługiwanych przez język wraz z przyjmowanymi typami danych.

% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[h!]
\begin{tabular}{@{}lllll@{}}
\toprule
Nazwa operacji & Operator & Semantyka & Typy przyjmowane & Typ zwracany \\ \midrule
Równy & == & arg1 == arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & Binarny \\
Nierówny & != & arg1 != arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & Binarny \\
Mniejszy & \textless{} & arg1 \textless arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & Binarny \\
Większy & \textgreater{} & arg1 \textgreater arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & Binarny \\
Mniejszy lub równy & \textless{}= & arg1 \textless{}= arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & Binarny \\
Większy lub równy & \textgreater{}= & arg1 \textgreater{}= arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & Binarny \\
Dodawanie & + & arg1 + arg2 & Liczbowe & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument lewy\end{tabular} \\
Odejmowanie & - & arg1 - arg2 & Liczbowe & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument lewy\end{tabular} \\
Mnożenie & * & arg1 * arg2 & Liczbowe & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument lewy\end{tabular} \\
Dzielenie & / & arg1 / arg2 & Liczbowe & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument lewy\end{tabular} \\
Negacja arytmetyczna & - & -arg & Liczbowy & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument\end{tabular} \\
Koniunkcja & \& & arg1 \& arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument lewy\end{tabular} \\
Alternatywa & | & arg1 | arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument lewy\end{tabular} \\
Alternatywa rozłączna & \textasciicircum{} & arg1 \textasciicircum arg2 & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument lewy\end{tabular} \\
Negacja logiczna & $\sim$ & $\sim$arg & \begin{tabular}[c]{@{}l@{}}Liczbowe,\\ binarne\end{tabular} & \begin{tabular}[c]{@{}l@{}}Taki sam jak\\ argument\end{tabular} \\ \bottomrule
\end{tabular}
\caption{Lista operatorów arytmetyczno-logicznych}
\label{tbl:operatory-arytmetyczno-logiczne}
\end{table}

\subsection{Instrukcje kontroli przepływu}
Aby zapewnić możliwość łatwego i czytelnego definiowania zachowań programu, języki programowania implementują różnego sposoby definiowania kontroli przepływu. Język uCricket implementuje następujące instrukcje pozwalające na taką kontrolę.

\subsubsection{Instrukcje warunkowe}
Instrukcja warunkowa pozwala na separacje bloku kodu i nadanie mu warunku, który spowoduje jego wykonanie. Definicja funkcji warunkowej odbywa się poprzez użycie słowa kluczowego \lstinline|if|, nawiasów okrągłych przyjmujących warunek i nawiasów klamrowych zawierających blok kodu. Warunek musi zwracać wartość typu boolowskiego.
\begin{lstlisting}
if (true) {
	// Code
}
\end{lstlisting}

\subsubsection{Pętle}
Dzięki pętlom możliwe jest wielorazowe wykonywanie kodu, dopóki warunek jest spełniany. Petlę definiuje się poprzez użycie słowa kluczowego \lstinline|while|, nawiasów okrągłych i nawiasów klamrowych. Tak samo jak w przypadku instrukcji warunkowej, warunek przekazywany do pętli musi zwracać dane typu boolowskiego.
\begin{lstlisting}
while (true) {
	// Code
}
\end{lstlisting}
 
\subsection{Funkcje}
W języku uCricket istnieje kilka kombinacji definicji funkcji:
\begin{itemize}
\item funkcja nie zwracająca wartości, bez argumentów,
\item funkcja nie zwracająca wartości, przyjmująca argumenty,
\item funkcja zwracająca wartość, bez argumentów,
\item funckja zwracająca wartość, przyjmująca argumenty. 
\end{itemize}

Podstawowa definicja funkcji składa się z słowa kluczowego \lstinline|func|, identyfikatora, otwierającego i zamykającego nazwiasu okrągłego oraz nawiasów klamrowych będących ciałem funkcji.
\begin{lstlisting}
func foo() {
	// Code
}
\end{lstlisting}

Funkcje mogą przyjmować argumenty. Wartości przekazywane do funkcji są kopiowane do nowych zmiennych, definiowanych w nawiasach okrągłych.
\begin{lstlisting}
func foo(Byte byteBar, Integer intBar) {
	// Code
}
\end{lstlisting}

Poprzez dodanie po słowie kluczowym \lstinline|func| nawiasów ostrokątnych z typem danych, możliwe jest zdefiniowanie funkcji zwracającej wartość. Po dodaniu do funkcji typu danych wymagane jest zwrócenie wartości, o odpowiednim typie, na końcu funkcji. Odbywa się to poprzez użycie słowa kluczowego \lstinline|return|. Możliwe jest także zwrócenie wartości we wnętrzu funkcji, co spowoduje przerwanie jej wykonywania i przejście do punktu jej wywołania.
\begin{lstlisting}
func<Integer> add(Integer x, Integer y) {
	return x + y;
}
\end{lstlisting}
\subsection{Przestrzenie nazw}
Przestrzenie nazw pozwalają na separację funkcji i zmiennych globalnych w obrębie kodu. Ich stosowanie jest wymagane. Możliwe jest umieszczenie wielu przestrzeni nazw w jednym pliku źródłowym. Definiowanie przestrzeni nazw odbywa się w następujący sposób:
\begin{lstlisting}
scope NazwaPrzestrzeni {

}
\end{lstlisting}
W klamrach przestrzeni nazw możliwe jest definiowanie funkcji, zmiennych i wskaźników globalnych. Aby odwołać się do zawartości innej przestrzeni, należy poprzedzić element właściwy danej przestrzeni, nazwą przestrzeni zawierającej.
\begin{lstlisting}
scope Main {
	func main() {
		Aux:auxilary();	
	}
}

scope Aux {
	func auxilary(){
		// Code
	}
}
\end{lstlisting}

\subsection{Komentarze}
Dodawanie komentarzy do kodu odbywa się poprzez dodanie przed tekstem dwóch ukośników. Może on zostać dodany w dowolnym miejscu kodu. Komentarz kończy znak nowej linii.
\begin{lstlisting}
scope Main {
	// Poczatek programu
	func main() {
		var<Integer> x = 3; // Zmienna liczbowa x
	}
}
\end{lstlisting}

%\begin{itemize}
%\item  wymagania sprzętowe i programowe
%\item  sposób instalacji
%\item  sposób aktywacji
%\item  kategorie użytkowników
%\item  sposób obsługi
%\item  administracja systemem
%\item  kwestie bezpieczeństwa
%\item  przykład działania
%\item  scenariusze korzystania z systemu (ilustrowane zrzutami z ekranu lub generowanymi dokumentami)
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%
%% RYSUNEK Z PLIKU
%
%\begin{figure}
%\centering
%\includegraphics[width=0.5\textwidth]{./graf/politechnika_sl_logo_bw_pion_pl.pdf}
%\caption{Podpis rysunku zawsze pod rysunkiem.}
%\label{fig:etykieta-rysunku}
%\end{figure}
%Rys. \ref{fig:etykieta-rysunku} przestawia …
%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%
%% WIELE RYSUNKÓW 
%
%\begin{figure}
%\centering
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Lewy górny rysunek.}
%    \label{fig:lewy-gorny}
%\end{subfigure}
%\hfill
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Prawy górny rysunek.}
%    \label{fig:prawy-gorny}
%\end{subfigure}
%
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Lewy dolny rysunek.}
%    \label{fig:lewy-dolny}
%\end{subfigure}
%\hfill
%\begin{subfigure}{0.4\textwidth}
%    \includegraphics[width=\textwidth]{./graf/politechnika_sl_logo_bw_pion_pl.pdf}
%    \caption{Prawy dolny rysunek.}
%    \label{fig:prawy-dolny}
%\end{subfigure}
%        
%\caption{Wspólny podpis kilku rysunków.}
%\label{fig:wiele-rysunkow}
%\end{figure}
%Rys. \ref{fig:wiele-rysunkow} przestawia wiele ważnych informacji, np. rys. \ref{fig:prawy-gorny} jest na prawo u góry.
%%%%%%%%%%%%%%%%%%%%%


 
%\begin{figure}
%\centering
%\begin{tikzpicture}
%\begin{axis}[
%    y tick label style={
%        /pgf/number format/.cd,
%            fixed,   % po zakomentowaniu os rzednych jest indeksowana wykladniczo
%            fixed zerofill, % 1.0 zamiast 1
%            precision=1,
%        /tikz/.cd
%    },
%    x tick label style={
%        /pgf/number format/.cd,
%            fixed,
%            fixed zerofill,
%            precision=2,
%        /tikz/.cd
%    }
%]
%\addplot [domain=0.0:0.1] {rnd};
%\end{axis} 
%\end{tikzpicture}
%\caption{Podpis rysunku po rysunkiem.}
%\label{fig:2}
%\end{figure}

